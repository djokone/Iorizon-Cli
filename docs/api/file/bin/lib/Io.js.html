<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">bin/lib/Io.js | iorizon-cli</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Command line tools to set workflow"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="iorizon-cli"><meta property="twitter:description" content="Command line tools to set workflow"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">bin/lib/Io.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">var IoLoader = require(&apos;./IoLoader&apos;)
var path = require(&apos;path&apos;);
var fs = require(&apos;fs&apos;);
var utils = require(&apos;./utils&apos;);
var shell = require(&quot;shelljs&quot;);
const reg = require(&apos;./ioRegex&apos;)
let debug = require(&apos;../lib/debugger&apos;).debug


class Io {
  constructor (config = {}, digest = false) {
    this.initProperties()
    if (!digest) {
      this.init()
    }
  }
  initProperties (config = {}) {
    this._process = false
    this._current = false
    if (config.process) {
      this._process = config.process
    }
    this.globalFolder = &apos;iorizon-cli&apos;
    this.enginePath = &apos;iorizon-cli/bin/iorizon&apos;
    this.enginePath = &apos;iorizon-cli/bin/iorizon&apos;
    this.ioFile = &apos;io.json&apos;
    this.commandPriority = [&apos;current&apos;, &apos;global&apos;]
    this._enginePath = false
    this._argv = false
    if (config.argv) {
      if (this._process === false) {
        this._process = process
      }
      this._process.argv = config.argv
    }
    this.isInit = false
  }

  /**
   * Require proxy to use alias shortcut in require function. 
   * Juste run the function to active the proxy.
   * @todo All to do
   */
  ioRequire () {
    // debug(&apos;io Require&apos;)
    require = new Proxy (require, {
      apply: function (target, thisArg, argument) {
        debug(target)
        debug(thisArg)
        debug(argument)
      }
    })
  }

  /**
   * Get the engine used for your command line tool, will be the parent process. If you want to
   * to create you&apos;re own follow the contribution guide
   * @return {[type]} [description]
   */
  get engine () {
    // debug(this.modulePath)
    if (!this._engine) {
      this._engine = new IoLoader(this.pathToIoFile(this.globalPathFile))
    }
    if (this.inModule &amp;&amp; this.modulePath) {
      this.module = this.argv.current.loader
      // this.module.argv = this.argv
      this.hasModule = true
    }  else {
      this.hasModule = false
    }
    console.log(this._engine)
    return this._engine
  }

  /**
   * Get the global path file
   * @return {String} Global io path file
   */
  get globalPathFile () {
    let GlobalPath = this.globalPathFolders
    return path.normalize(path.join(...GlobalPath))
  }

  set globalPathFile (value) {
    console.warn(&quot;cannot set this path&quot;)
    return false
  }
  get cmd () {
    if (typeof this.argv.current !== &apos;undefined&apos; &amp;&amp; Array.isArray(this.argv.current.cmd)) {
      debug(this.argv)
      for (let cmd in this.argv.current.cmd) {
        return cmd
        break
      }
      return false
    } else if (Array.isArray(this.argv.cmd)) {
      // debug(this.argv.cmd)
      for (let cmd of this.argv.cmd) {
        return cmd
        break
      }
      return false
    }
  }
  init () {
    this.isInit = true
  }
  get current () {
    if (this._current === false) {
      this._current = new IoLoader()
    }
    return this._current
  }
  get hasCurrentModules () {
    return typeof this.current.content.modules !== &quot;undefined&quot;
  }

  get process () {
    if (this._process === false) {
      return process
    } else {
      return this._process
    }
  }

  get processArgv () {
    if (this.process.argv) {
      return this.process.argv
    } else {
      false
    }
  }

  get module () {
    let modules = {}

    return modules
  }

  get options () {
    let res = this._syncOptions()
    if (this.hasModule &amp;&amp; this.current.isLoaded) {
      let currentRes = this.current.modules.getModuleOptions(this.parentCmd[0])
      // debug(currentRes)
      res = Object.assign({}, res, currentRes)
    }
    return res
  }
  //sync current options
  _syncOptions () {
    let res = {}
    let current = this.argv.current
    current.loader._options.each((v, k) =&gt; {
      let opt = current.loader._options.get(v)
      res[opt.meta.option.name] = opt.value
    })
    for (let option in current.options) {
      let opt = current.options[option]
      res[option] = opt.value
    }
    return res
  }
  addOptions (key, value) {
    // debug(this.argv.current)
  }
  /**
   * Run the current sub command
   */
  runSubCommand () {
    if (this.isInit) {
      // debug(this.cmd)
      if (this.cmd) {
        // debug(this.current.modules.has(this.cmd))
        // debug(this)
        // debug(this.hasModule)
        if ((this.hasModule) &amp;&amp; this.inModule &amp;&amp; this.module.isLoaded &amp;&amp; this.module.modules.has(this.cmd)) {
          this.module.modules.run(this.cmd, this.argv)
        } else if (this.hasCurrentModules &amp;&amp; this.current.isLoaded &amp;&amp; this.current.modules.has(this.cmd)) {
          this.current.modules.run(this.cmd, this.argv)
        } else if (this.engine.isLoaded &amp;&amp; this.engine.modules.has(this.cmd)) {
          this.engine.modules.run(this.cmd, this.argv)
        } else {
          console.warn(&apos;This cmd : &apos; + this.cmd + &apos;, doesn\&apos;t exist&apos;)
        }
      }
    } else {
      console.error(&apos;You have to call init() function before running subcommands !&apos;)
    }  
  }
  /**
   * Parse node js process.argv array to an object
   * @param  {[Array]} argvs [Process argv array to parse]
   * @return {[Object]}      [Object with path, cmd and options sort out]
   * 
   * @exemples
   * e:\sites\Projets\ImperialInternational\imperial-cakephp3
   * $ io --global build --silent save
   * 
   * e:\sites\Projets\ImperialInternational\imperial-cakephp3\io.json
   * &quot;modules&quot;: {
   *    &quot;build&quot;: {
   *      &quot;url&quot;: &quot;e:\sites\factory\buildManager&quot;
   *    }
   * }
   * 
   * e:\sites\factory\buildManager\io.json
   * &quot;options&quot;: {
   *   &quot;--silent&quot;: [true]
   * }
   * &quot;modules&quot;: {
   *   &quot;save&quot;: {
   *     &quot;url&quot;: &quot;./bin/save&quot;
   *    }
   * }
   * last spawn 
   * argvs = []
   * @todo 
   * Make a proper deep object
   ********************************/
  parseArgv (argvs = this.process.argv) {
    let parsed = {}
    parsed.process = []
    parsed.all = argvs.slice(1)
    // reg.path.absolute.test(argvs[2]) ? parsed.process.io = argvs[2] : parsed.process.io = argvs[1]
    parsed.process.all = []
    parsed.process.argvs = argvs
    parsed.cmd = []
    parsed.options = {}
    let index = 0
    let prev = {}
    let meta = {
      processCount: 0,
      cmdProcessCount: 0,
      cmdCount: 0,
      optionsCount: 0,
      current: {
        process: -1
      }
    }
    let currentProcess = 0
    debug(argvs)
    // Each argv throw the spwan node script
    for (let argv of argvs) {
      debug(argv)
      debug(&apos;before&apos;)
      debug(meta)
      meta.current.argv = argv
      meta.current.index = index
      let data = {}
      // If it is a path, so it&apos;s a process
      if (path.isAbsolute(argv)) {
        meta.options = {}
        meta.cmd = false
        meta.process = {}
        meta.cmdProcessCount = 0
        meta.current.process++
        let ioPath = this.pathToIoFile(argv)
        meta.current.ioPath = ioPath
        let loader = false
        if (index === 1) {
          ioPath = this.pathToIoFile(this.process.mainModule.filename)
        }
        if (ioPath !== false) {
          loader = new IoLoader(ioPath)
        }
        data = {
          process: argv,
          loader,
          cmd: false,
          options: {},
          // currentCmd: {},
          cmdLength: meta.cmdProcessCount,
          hasCmd: false
        }
        meta.process.global = false
        if (index === 1) {
          meta.process.key = &apos;current&apos;
          parsed.current = data
          parsed.childs = []
        } else if (index &gt; 1) {
          meta.process.key = &apos;childs&apos;
          parsed.childs.push(data)
          meta.process.indexKey = parsed.childs.length - 1
        }
        debug(argv)
        debug(this.isEngineProcess(argv))
        if (this.isEngineProcess(argv)) {
          meta.process.global = true
          meta.process.type = &apos;process&apos;
          meta.current.type = &apos;process&apos;
          meta.process.value = argv
          meta.process.key = &apos;global&apos;
          parsed.global = data
          parsed.global.options = {}
        }
      }
      let hasOptionsHandled = typeof meta.options !== &apos;undefined&apos; &amp;&amp; 
        typeof meta.options.handle !== &apos;undefined&apos; &amp;&amp; 
        meta.options.handle &gt; 0
      let cmdKey = &apos;cmd&apos;

      if (!hasOptionsHandled &amp;&amp; reg.cmd.test(argv)) {
        meta.cmdProcessCount++
        // if (meta.cmdProcessCount === 1 &amp;&amp; !meta.process.global) {
        //   cmdKey = &apos;currentCmd&apos;
        // }
      }
      let target
      // Handle the reference to manipulate it in next conditions
      if (meta.process.global) {
        target = parsed.global
      } else if (meta.process.key === &apos;childs&apos;) {
        target = parsed[meta.process.key][meta.process.indexKey]
      } else {
        target = parsed[meta.process.key]
      }

      // if it&apos;s a options value
      if (
        hasOptionsHandled
        ) {
        meta.current.type = &apos;optVal&apos;
        let targetOpt
        if (meta.cmd) {
          targetOpt = target[cmdKey][meta.cmd.key].options[meta.options.meta.option.name].value
        } else {
          targetOpt = target.options[meta.options.meta.option.name].value
        }
        if (meta.options.meta.argCount === 1) {
          targetOpt = argv
        } else {
          targetOpt[meta.options.meta.argCount - meta.options.handle] = argv
        }
        meta.options.handle--
        if (meta.options.handle &lt; 1) {
          meta.cmd = false
        }
      }
      // if it&apos;s a command to handle
      else if (reg.cmd.test(argv)) { 
        meta.cmd = {}
        meta.current.type = &apos;cmd&apos;
        meta.cmd.type = &apos;cmd&apos;
        meta.cmd.key = argv
        // parsed[meta.process.key].cmd[meta.cmd.key].arg.push(argv)
        let cmd = {
          name: argv,
          options: {},
          arg: []
        }
        parsed.cmd.push(argv)
        debug(cmdKey)
        if (typeof target.cmd === &apos;boolean&apos;) {
          target[cmdKey] = {}
        }
        target[cmdKey][argv] = cmd
        parsed[meta.process.key].hasCmd = true
        meta.cmdCount++
        target.cmdLength = meta.cmdCount
      }
      // If it&apos;s a option @exemple --deep or -d
      if (reg.option.normal.test(argv) || reg.option.shortcut.test(argv)) {
        // debug(meta)
        meta.current.type = &apos;opt&apos;
        let targetOpt
        debug(meta)
        debug(target)
        debug(cmdKey)
        debug(meta.cmd.key)
        if (meta.cmd) {
          targetOpt = target[cmdKey][meta.cmd.key].options
        } else {
          targetOpt = target.options
        }
        meta.options = {}
        let opt = target.loader._options.get(argv)
        if (target.loader._options &amp;&amp; opt) {
          meta.options = opt
          let option = {
            value: opt.value,
            key: opt.meta.option.call
          }
          targetOpt[opt.meta.option.name] = option
          if (opt.meta.value.type === &apos;boolean&apos;) {
            targetOpt[opt.meta.option.name].value = !opt.value
          }
          meta.options.handle = opt.meta.argCount
        } else {
          throw new Error(&apos;Io \&apos;&apos; + argv + &apos;\&apos; option is missing in &apos; + target.loader.name + &apos; configuration at location: &apos; + path.normalize(path.resolve(target.process, target.loader.ioFileName)))
        }
      }
      debug(&apos;after&apos;)
      debug(meta)
      debug(parsed.current)
      prev = {meta, data}
      index++
    }

    // if (typeof parsed.current !== &apos;undefined&apos;) {
    //   this.module = parsed.current.loader
    //   this.hasModule = true
    // }
    return parsed
  }
  get parentCmd () {
    let cmd = []
    for (let child of this.argv.childs) {
      for (let ccmd in child.currentCmd) {
        cmd.push(ccmd)
        break
      }
    }
    return cmd
  }
  set argv (val) {
    if (Array.isArray(val)) {
      this._processArgv = val
      this._argv = this.parseArgv(val)
    } else {
      this._argv = val
    }
    
  }

  /**
   * Get Argv and parse argv if it&apos;s the first argv is called
   * @return {[type]} [description]
   */
  get argv () {
    if (!this._argv) {
      this._argv = this.parseArgv()
    }
    return this._argv
  }
  get modulePath () {
    // debug(this.cmd)
    let url = this.argv.current.loader.modules.getUrl(this.cmd)
    if (url) {
      return this.pathToIoFile(url)
    } else {
      return false
    }
    // debug(this.argv.current.process)
    // debug(this.argv.current.loader.modules)
    // // this.argv.current.
    // if (/bin$/.test(path.dirname(this.argv.process[1].path))) {
    //   return path.resolve(path.dirname(this.argv.process[1].path), &apos;../&apos;)
    // } else {
    //   return path.dirname(this.argv.process[1].path)
    // }
  }

  /**
   * Check if the class has been initialize into a module
   * @return {Boolean} [description]
   */
  get inModule () {
    // debug(this.hasModule )
    if (this.hasModule &amp;&amp; this.module) {
      return this.module.modules[this.cmd] !== &apos;undefined&apos;
    } else {
      return false
    }
  }

  /**
   * Test if a specifique path is come from the engine
   * @param  {String}  pathTo Path you want to check
   * @return {Boolean}        Return true if the path come from 
   *                          the engine
   */
  isEngineProcess (pathTo) {
    let find = utils.escape(path.normalize(this.enginePath)) + &apos;$&apos;
    pathTo = path.normalize(pathTo)
    let rep = new RegExp(find, &apos;i&apos;).test(pathTo)
    // debug(rep)
    return rep
  }

  /**
   * Get the path directory where the current command is run
   * @return {String} Current Path Directory
   */
  get currentPath () {
    return shell.pwd().stdout
  }
   /**
   * Get an array of all the global path folder
   * @return {[Array]} Array with all the folder names
   */
  get globalPathFolders () {
    return this.globalPath.split(path.sep).slice(0, this.ioFolderKey + 1)
  }

  /**
   * Set the global path
   * @param  {[type]} val [description]
   * @return {[type]}     [description]
   */
  set globalPath (val) {
    this._enginePath = val
  }

  /**
   * Get global path
   * @return {String} return engine global path 
   */
  get globalPath () {
    if (!this._globalPath) {
      this.globalPath = __dirname
    } 
    return this._globalPath
  }

  get ioFolderKey () {
    let IoFolderKey = 0
    for (let folder of this.globalPath.split(path.sep)) {
      if (folder === this.globalFolder) {
        break
      }
      IoFolderKey++
    }
    return IoFolderKey
  }

  /**
   * Get the path to a Io root file from a given folder. 
   * This function will search in all the parents folder
   * to return the first file it find.
   * 
   * @param  {[type]} pathTo The path where you want to start the research
   * @return {Boolean}        return true if a root file&apos;s founded
   */
  pathToIoFile (pathTo) {
    let first = true
    pathTo = path.normalize(pathTo)
    let rootPath = path.normalize(path.parse(pathTo).root)
    let file
    let continu = true
    do {
      pathTo = path.normalize(pathTo)
      if (!first) {
        pathTo = path.resolve(pathTo, &apos;../&apos;)
      } else {
        first = false
      }
      file = path.resolve(pathTo, this.ioFile)
      continu = !(fs.existsSync(file) || pathTo === rootPath)
      if (!continu &amp;&amp; !fs.existsSync(file)) {
        pathTo = false
      }
    } while (continu)
    return pathTo
  }
}

module.exports = Io
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
